#
# Copyright and User License
# ~~~~~~~~~~~~~~~~~~~~~~~~~~
# Copyright 2006-2019 CERN and INFN
# 
#
# Please consult the LICENSE file for the license 
#
# DISCLAIMER
# ~~~~~~~~~~
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT
# NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY, OF
# SATISFACTORY QUALITY, AND FITNESS FOR A PARTICULAR PURPOSE
# OR USE ARE DISCLAIMED. THE COPYRIGHT HOLDERS AND THE
# AUTHORS MAKE NO REPRESENTATION THAT THE SOFTWARE AND
# MODIFICATIONS THEREOF, WILL NOT INFRINGE ANY PATENT,
# COPYRIGHT, TRADE SECRET OR OTHER PROPRIETARY RIGHT.
#
# LIMITATION OF LIABILITY
# ~~~~~~~~~~~~~~~~~~~~~~~
# THE COPYRIGHT HOLDERS AND THE AUTHORS SHALL HAVE NO
# LIABILITY FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL,
# CONSEQUENTIAL, EXEMPLARY, OR PUNITIVE DAMAGES OF ANY
# CHARACTER INCLUDING, WITHOUT LIMITATION, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES, LOSS OF USE, DATA OR PROFITS,
# OR BUSINESS INTERRUPTION, HOWEVER CAUSED AND ON ANY THEORY
# OF CONTRACT, WARRANTY, TORT (INCLUDING NEGLIGENCE), PRODUCT
# LIABILITY OR OTHERWISE, ARISING IN ANY WAY OUT OF THE USE OF
# THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
# DAMAGES.
#
# Author:	Vasilis.Vlachoudis@cern.ch
# Date:	14-Dec-2007

__author__ = "Vasilis Vlachoudis"
__email__  = "Paola.Sala@mi.infn.it"

import os
import sys
import math
import bmath
import string
import random
import Input

_DENSITY_LIMIT = 0.1	# Ligther than that is ignored
_FAR_AWAY      = 1E10

__IN    = "-+*/:;<>,.&()[]{}!@#$%^&*=|"
try:
	_TRANS  = string.maketrans(__IN,"_"*len(__IN))
except AttributeError:
	# For python3
	_TRANS  = str.maketrans(__IN,"_"*len(__IN))

# Colors definitions
_COLORS = [	"Aquamarine", "BakersChoc", "BlueViolet", "Brass", "BrightGold",
		"Bronze", "Bronze2", "Brown", "CadetBlue", "CoolCopper", "Copper",
		"Coral", "CornflowerBlue", "DarkBrown", "DarkGreen", "DarkOliveGreen",
		"DarkOrchid", "DarkPurple", "DarkSlateBlue", "DarkSlateGray",
		"DarkSlateGrey", "DarkTan", "DarkTurquoise", "DarkWood", "DimGray",
		"DimGrey", "DkGreenCopper", "DustyRose", "Feldspar", "Firebrick",
		"Flesh", "ForestGreen", "Gold", "Goldenrod", "Gray", "GreenCopper",
		"GreenYellow", "Grey", "HuntersGreen", "IndianRed", "Khaki",
		"LightBlue", "LightGray", "LightGrey", "LightSteelBlue", "LightWood",
		"Light_Purple", "LimeGreen", "MandarinOrange", "Maroon", "Med_Purple",
		"MediumAquamarine", "MediumBlue", "MediumForestGreen", "MediumGoldenrod",
		"MediumOrchid", "MediumSeaGreen", "MediumSlateBlue", "MediumSpringGreen",
		"MediumTurquoise", "MediumVioletRed", "MediumWood", "Mica",
		"MidnightBlue", "Navy", "NavyBlue", "NeonBlue", "NeonPink",
		"NewMidnightBlue", "NewTan", "OldGold", "Orange", "OrangeRed",
		"Orchid", "PaleGreen", "Pink", "Plum", "Quartz", "RichBlue", "Salmon",
		"Scarlet", "SeaGreen", "SemiSweetChoc", "Sienna", "Silver", "SkyBlue",
		"SlateBlue", "SpicyPink", "SpringGreen", "SteelBlue", "SummerSky",
		"Tan", "Thistle", "Turquoise", "VLightGray", "VLightGrey", "VeryDarkBrown",
		"Very_Light_Purple", "Violet", "VioletRed", "Wheat", "YellowGreen" ]

#-------------------------------------------------------------------------------
# Convert a vector to povray string assuming x=-x
#-------------------------------------------------------------------------------
def vec(v):
	return "<%.16g %.16g %.16g>"%(-v[0], v[1], v[2])

#-------------------------------------------------------------------------------
# Return a valid povray name
#-------------------------------------------------------------------------------
def name(s):
	# First convert all invalid characters to underscore (_)
	# Minimize the occurencies of _
	s = s.encode("ascii","replace")
	new = s.translate(_TRANS)
	while True:
		old = new
		new = new.replace("__","_")
		if old == new: break
	return old

#-------------------------------------------------------------------------------
def header(fout, input, overwriteinc=False):
	fn,ext = os.path.splitext(fout.name)
	fninc = "%s.inc"%(fn)
	fout.write("// Povray file generated by flair\n")
	fout.write("// FLUKA Input: %s\n"%(input.filename))
	fout.write('#include "colors.inc"\n')
	fout.write('#include "textures.inc"\n')
	fout.write('//#include "fluka.inc"\n\n')
	fout.write('#include "%s"\n'%(fninc))

	# Generate the default include file with materials
#	try:
#		# Check if it exists
#		os.stat(fninc)
#		if not overwriteinc: return
#	except OSError:
#		pass

	f = open(fninc,"w")

	# Create a default & lights camera
	f.write("// Povray include file generated by flair\n")
	f.write("// FLUKA Input: %s\n\n"%(input.filename))
	f.write("// Ambient light\n")
	f.write("global_settings{ambient_light Gray30}\n\n")
	f.write("sky_sphere {\n")
	f.write("\tpigment {\n")
	f.write("\t\tgradient y\n")
	f.write("\t\tcolor_map {\n")
	f.write("\t\t[0.000 0.002	color rgb <0.2, 0.2, 1.0>\n")
	f.write("\t\t			color rgb <0.2, 0.2, 1.0>]\n")
	f.write("\t\t[0.002 0.200	color rgb <0.2, 0.1, 0.8>\n")
	f.write("\t\t			color rgb <0.2, 0.2, 0.3>]\n")
	f.write("\t\t}\n")
	f.write("\t\tscale 2\n")
	f.write("\t\ttranslate -1\n")
	f.write("\t}\n")
	f.write("\tpigment {\n")
	f.write("\t\tbozo\n")
	f.write("\t\tturbulence 0.65\n")
	f.write("\t\toctaves 6\n")
	f.write("\t\tomega 0.7\n")
	f.write("\t\tlambda 2\n")
	f.write("\t\tcolor_map {\n")
	f.write("\t\t[ 0.0 0.1	color rgb <0.85, 0.85, 0.85>\n")
	f.write("\t\t			color rgb <0.75, 0.75, 0.75>]\n")
	f.write("\t\t[ 0.1 0.5	color rgb <0.75, 0.75, 0.75>\n")
	f.write("\t\t			color rgbt <1, 1, 1, 1>]\n")
	f.write("\t\t[ 0.5 1.0	color rgbt <1, 1, 1, 1>\n")
	f.write("\t\t			color rgbt <1, 1, 1, 1>]\n")
	f.write("\t\t}\n")
	f.write("\t\tscale <0.2, 0.5, 0.2>\n")
	f.write("\t}\n")
	f.write("\trotate -135*x\n")
	f.write("}\n")

	f.write("// Light sources\n")
	f.write("light_source {\n")
	f.write("\t<120,240,100>\n")
	f.write("\tcolor White\n")
	f.write("}\n\n")
	f.write("light_source {\n")
	f.write("\t<-100,240,50>\n")
	f.write("\tcolor Gray80\n")
	f.write("\tspotlight\n")
	f.write("\tradius 50\n")
	f.write("\tfalloff 60\n")
	f.write("\tpoint_at <0,0,0>\n")
	f.write("}\n\n")
	f.write("// Cameras\n")
	f.write("camera {\n")
	f.write("\tlocation <100, 180, 250>\n")
	f.write("\tdirection <0, 0, 1>\n")
	f.write("\tangle 40\n")
	f.write("\tup <0, 1, 0>\n")
	f.write("\tright <4/3, 0, 0>\n")
	f.write("\tlook_at  <0, 0, 0>\n")
	f.write("}\n\n")

	f.write("//---------------------- FLOOR --------------------------------\n")
	f.write("plane { y, 0\n")
	f.write("\ttexture {\n")
	f.write("\t\tpigment {\n")
	f.write("\t\tchecker\n")
	f.write("\t\tcolor White\n")
	f.write("\t\tcolor Gray70\n")
	f.write("\t\tscale 20\n")
	f.write("\t\t}\n")
	f.write("\t}\n")
	f.write("}\n")
	f.write("//---------------------- Axis ---------------------------------\n")
	f.write("#declare _axis=union {\n")
	f.write("        cylinder { <0,0,0>,<0.9,0,0>,0.015 open }\n")
	f.write("        cone { <0.9,0,0>,0.03,<1,0,0>,0 open }\n")
	f.write("\ttexture {pigment {Candy_Cane scale 0.2} finish {ambient 0.15 diffuse 0.8}}\n")
	f.write("\tno_shadow\n")
	f.write("}\n")
	f.write("#local _axisScale=100;\n")
	f.write("object {_axis rotate z*180 scale _axisScale} // X-Axis\n")
	f.write("object {_axis rotate z*90  scale _axisScale} // Y-axis\n")
	f.write("object {_axis rotate y*-90 scale _axisScale} // Z-axis\n")

	#Ncolors = words(c)
	#CR  = "0A"x
	matCards = input["MATERIAL"]
	for mat in input.materialList():
		# Find density of material
		for card in matCards:
			if card.ignore(): continue
			if card.sdum() == mat: break
		else:
			# Search default materials
			for card in Input._defaultMaterials:
				if card.sdum() == mat: break

		if card.numWhat(3) < _DENSITY_LIMIT: continue

		matname = name(mat).upper()

		# Special materials
		if   matname=="WATER" or matname=="H2O" or matname=="D2O":
					color = "Water"
		elif matname=="ALUMINUM":color="Aluminum"
		elif matname=="GOLD":	color="Gold_Metal"
		elif matname=="SILVER":	color="Silver_Metal"
		elif matname=="IRON":	color="Aluminum"
		elif matname=="STEEL":	color="Chrome_Metal"
		elif matname=="COPPER":	color="Copper_Metal"
		elif matname=="CARBON":	color="Copper_Metal"
		elif matname=="GLASS":	color="Glass"
		elif matname=="CONCRETE":	color= \
					"texture {\n" \
					"\tpigment {color <0.8,0.8,0.7>}\n" \
					"\tnormal { bumps 0.2 scale 0.2 }\n" \
					"\tfinish { ambient 0.2 diffuse 0.6 phong .75 }}"
		elif matname=="MARBLE":	color="White_Marble"
		else:
			# Choose a random color
			color = "texture {pigment {color %s}}" % \
				_COLORS[random.randint(0, len(_COLORS)-1)]
		f.write("#declare mat_%s=%s\n"%(matname, color))
	f.close()

#-------------------------------------------------------------------------------
def exportBodies(fout, input):
	fout.write("\n// ---- Bodies ----\n")

	# Loop all cards
	for card in input.cardlist:
		if not card.isGeo(): continue
		if len(card.tag) != 3: continue
		if card.ignore(): continue
		if card.tag == "END": continue

		name = card.sdum()
		if name == "": continue

		for line in str(card).splitlines():
			fout.write("// %s\n"%(line))
		fout.write("#declare %s = "%(name))
		if   card.tag == "RPP":
			fout.write("box {<%.16g,%.16g,%.16g>, <%.16g,%.16g,%.16g>}\n" % \
				(-card.numWhat(1), card.numWhat(3), card.numWhat(5), \
				 -card.numWhat(2), card.numWhat(4), card.numWhat(6)))
		#-----------------------------------------------------------------------zxw20240827----For TET, added by zxw
		elif   card.tag == "TET":
			P  = card.bodyP1()
			V1 = card.bodyP2()
			V2 = card.bodyPn(3)
			V3 = card.bodyPn(4)
			fout.write("box {<%.16g,%.16g,%.16g>, <%.16g,%.16g,%.16g>, <%.16g,%.16g,%.16g>, <%.16g,%.16g,%.16g>\n" \
			  % (P[0], P[1], P[2], V1[0], V1[1], V1[2], V2[0], V2[1], V2[2], V3[0], V3[1], V3[2]))
		#----------------------------------------------------------------------------------	
		elif card.tag == "BOX":
			P  = card.bodyP()
			lx = card.bodyX().length()
			ly = card.bodyY().length()
			lz = card.bodyZ().length()
			fout.write("box {<0,0,0>, <%.16g,%.16g,%.16g>\n" % (lx, ly, lz))
			nx = card.bodyX(); nx.norm()
			ny = card.bodyY(); ny.norm()
			nz = card.bodyZ(); nz.norm()
			fout.write("\tmatrix <%.16g, %.16g, %.16g,\n"%(-nx[0],-ny[0],-nz[0]))
			fout.write("\t\t%.16g, %.16g, %.16g,\n"%(nx[1],ny[1],nz[1]))
			fout.write("\t\t%.16g, %.16g, %.16g,\n"%(nx[2],ny[2],nz[2]))
			fout.write("\t\t%.16g, %.16g, %.16g>}\n"%(P[0], P[1], P[2]))

		elif card.tag == "SPH":
			fout.write("sphere {%s, %.16g}\n"%(vec(card.bodyP()), card.bodyR()))

		elif card.tag == "RCC":
			P = card.bodyP()
			Z = card.bodyZ()
			fout.write("cylinder {%s, %s, %.16g}\n" % \
					(vec(P), vec(P+Z), card.bodyR()))

		elif card.tag == "TRC":
			P = card.bodyP()
			Z = card.bodyZ()
			baseRadius = card.numWhat(7)
			apexRadius = card.numWhat(8)
			fout.write("cone {%s, %.16g, %s, %.16g}\n" % \
				(vec(P),   baseRadius,
				 vec(P+Z), apexRadius))

		#elif card.tag == "ELL":
		#	WriteEllipsoid
		#elif card.tag == "WED":
		#	WriteAngleWedge
		#elif card.tag == "ARB"
		#	WritePolyhedron

		elif card.tag == "XYP":
			fout.write("plane {z, %.16g}\n"%(card.numWhat(1)))

		elif card.tag == "XZP":
			fout.write("plane {y, %.16g}\n"%(card.numWhat(1)))

		elif card.tag == "YZP":
			fout.write("plane {x, %.16g inverse}\n"%(-card.numWhat(1)))

		elif card.tag == "PLA":
			N = card.bodyN()
			N.norm()
			fout.write("plane {%s, %.16g}\n"%(vec(N), N.dot(card.bodyP())))

		elif card.tag in ("XCC", "YCC", "ZCC"):
			P = card.bodyP()
			r = card.bodyR()

			a = b = c = 1.0/r**2
			if   card.tag == "XCC": a = 0.0
			elif card.tag == "YCC": b = 0.0
			elif card.tag == "ZCC": c = 0.0

			g =  2.0*P[0]*a
			h = -2.0*P[1]*a
			i = -2.0*P[2]*a

			j = a*P.length2() - 1.0

			fout.write("quadric {<%.16g,%.16g,%.16g>,<0,0,0>,<%.16g,%.16g,%.16g>,%.16g}\n" \
				% (a,b,c, g,h,i, j))

		elif card.tag == "REC":
			P = card.bodyP()
			X = card.bodyX()
			Y = card.bodyY()
			Z = card.bodyZ()
			a = 1.0/X.length2()
			b = 1.0/Y.length2()
			X.norm()
			Y.norm()
			Z.norm()
			fout.write("intersection {\n")
			fout.write("\t\tquadric {<%.16g,%.16g,0>,<0,0,0>,<0,0,0>,-1\n"%(a,b))
			fout.write("\t\tmatrix <%.16g, %.16g, %.16g,\n"%(X[0], Y[0], Z[0]))
			fout.write("\t\t\t%.16g, %.16g, %.16g,\n"%(X[1], Y[1], Z[1]))
			fout.write("\t\t\t%.16g, %.16g, %.16g,\n"%(X[2], Y[2], Z[2]))
			fout.write("\t\t\t%.16g, %.16g, %.16g>\n"%(P[0], P[1], P[2]))
			fout.write("\t\tplane {%s, %.16g inverse}\n"%(vec(Z), Z.dot(P)))
			Ptop = P + card.bodyZ()
			fout.write("\t\tplane {%s, %.16g}\n"%(vec(Z), Z.dot(Ptop)))
			fout.write("\t}\n")

		elif card.tag in ("XEC", "YEC", "ZEC"):
			xo, yo, zo = card.bodyP()
			a,  b,  c  = card.bodyR()

			if a!=0.0: a = 1/a**2
			if b!=0.0: b = 1/b**2
			if c!=0.0: c = 1/c**2

			xo = -xo
			g  = -2.0 * a * xo
			h  = -2.0 * b * yo
			i  = -2.0 * c * zo
			j  = a*xo**2 + b*yo**2 + c*zo**2 - 1.0
			fout.write("quadric {<%.16g,%.16g,%.16g>,<0,0,0>,<%.16g,%.16g,%.16g>,%.16g}\n" \
				% (a,b,c, g,h,i, j))

		else:
			raise Exception("Unknown body %s"%(card.tag))

#-------------------------------------------------------------------------------
def exportRegions(fout, input):
	fout.write("\n\n// ------ Regions ------\n")
	input.regionProperties()

	region = None
	expr   = ""
	for card in input.cards["REGION"]:
		if card.ignore(): continue
		if card.sdum()=="&":
			# append to previous expression
			expr += card.extra()
			continue

		if region is None:
			# Remember starting region
			region = card
			expr   = region.extra()
			continue

		_exportRegion(fout, region, expr)

		# Remember starting region
		region = card
		expr   = region.extra()

	# Last region
	if region: _exportRegion(fout, region, expr)

#-------------------------------------------------------------------------------
def _exportRegion(fout, region, expr):
	# Find material
	try:
		material = region["@material"]
	except:
		sys.stderr.write("\nERROR: region %s is not assigned material\n"%(region.sdum()))
		return True

	try: density = float(material.what(3))
	except: density = 0.0
	if density <= _DENSITY_LIMIT: return True

	# Write card
	fout.write("\n// Region: %s\tMaterial: %s\n\n"%(region.sdum(), material.sdum()))
	for line in str(region).splitlines():
		fout.write("// %s\n"%(line))

	region_expr = expr.split()	# remove spaces
	if len(region_expr)==0: return True
	region_expr = "".join(region_expr)

	if region_expr.find("#")>=0 or region_expr.find("(")>=0:
		sys.stderr.write("ERROR region %s contains parenthesis\n" \
			%(region.sdum()))
		return True

	region_expr = region_expr.replace("+", " + ")
	region_expr = region_expr.replace("-", " - ")
	region_expr = region_expr.replace("|", " | ")
	region_expr = region_expr.split()

	# Remove the first union operator
	if region_expr[0] == "|":
		del region_expr[0]

	# Search for unions
	try:
		i = region_expr.index("|")
		fout.write("union {\n\tintersection {\n")
		prefix = "\t\t"
	except:
		fout.write("intersection {\n")
		prefix = "\t"

	# construct the povray region line
	for item in region_expr:
		inverse = ""
		if item == "|":
			fout.write("\t}\n\tintersection {\n")
		elif item == "+":
			pass
		elif item == "-":
			inverse = " inverse"
		else:
			fout.write("%sobject {%s%s}\n"%(prefix,item,inverse))
	if prefix == "\t\t": fout.write("\t}\n")
	fout.write("\ttexture {mat_%s}\n"%(name(material.sdum())))
	fout.write("}\n")
	return False

#-------------------------------------------------------------------------------
def export(input, filename):
	fout = open(filename, "w")
	input.preprocess()
	header(fout, input)
	exportBodies(fout, input)
	exportRegions(fout, input)
	fout.close()
